package main

import "fmt"

// 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

// 示例 1:

// 输入: "abcabcbb"
// 输出: 3
// 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
// 示例 2:

// 输入: "bbbbb"
// 输出: 1
// 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
// 示例 3:

// 输入: "pwwkew"
// 输出: 3
// 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
//      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
// 思路

// 题目要求连续， 我们考虑使用滑动窗口。 而这道题就是窗口大小不固定的滑动窗口题目，然后让我们求满足条件的窗口大小的最大值，这是一种非常常见的滑动窗口题目。

// 算法：

// 用一个 hashmap 来建立字符和其出现位置之间的映射。同时维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。

//     如果当前遍历到的字符从未出现过，那么直接扩大右边界；

//     如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；

//     重复（1）（2），直到窗口内无重复元素；

//     维护一个全局最大窗口 res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果;

//     最后返回 res 即可;
// map的key是唯一的
func NoneRepeat(s string) {
	m := make(map[byte]int)
	left, max := 0, 0
	//判断当前字符有没有出现过
	//如果出现过，并且出现位置》子串起始位置，则更新起始位置到最新的位置，即从当前子串跳到下个子串
	for i, v := range []byte(s) {
		if j, ok := m[s[i]]; ok && j >= left {
			left = j + 1
			fmt.Println("map key is j: ; left values is :", j, left)
		}
		if i-left+1 > max {
			max = i - left + 1
		}
		m[v] = i // map的key是唯一的, 有重复的v就取最新的i下标
		fmt.Println("map is ", m)
	}
	// fmt.Println(m)

}

func main() {
	s1 := "abcdbebc"
	NoneRepeat(s1)
}
